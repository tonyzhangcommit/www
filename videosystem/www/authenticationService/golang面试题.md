### 常见数据结构
#### map
- map 底层实现结构体是什么，map 作为函数参数，操作会影响到原始值吗？为什么
    hmap 是map 的底层结构体表示。在使用make 函数创建map 时，底层调用的是 makemap 函数， 返回的是*hmap类型， 所以map 为引用类型。作为函数参数，是会影响原始值。
- 怎么判断map 是否存在某个元素？
    逗号，ok 语法
-  讲一下map 扩容过程，装载因子是什么？
    首先，当map 中的元素超过了 num桶 * 装载因子的数量时，会发生扩容。
    扩容步骤： 分配更大的bucket 数组， 每次从bucket中取元素或者写入元素时， 会将一部分的old bucket 数据迁移到新的bucket，渐进式的迁移，这也说明了为什么遍历是无序的。
- map 遍历为什么是无序的？从底层代码实现解释下。
    原因同上。 极限情况下，初始化后，新增元素没有触发扩容发生， go 并不是固定的从0号桶开始的，这也是强制无序的。
- map 为什么不是并发安全的？从底层代码实现解释下。
    在CRUD的操作中， 都会检测写标志，当发现写标志等于1，会发生painc; h.flags&hashWriting == 0
- float 类型可以作为map 的key 吗？map 中key 的要求是什么？从源码角度解释下。
    理论上可以比较的类型都可以作为key,除了 slice map func ，其中 结构体也可以，只要hash 后的值相等，就可以代表是相等的。
    但是float 类型作为key 会造成一些不可控的问题：比如：
    fmt.Println(math.Float64bits(2.4) == math.Float64bits(2.4000000000000000000000001))  输出true
    而且  math.NaN() != math.NaN()
    所以这里不建议。
- 可以对map 元素取地址吗？
    不可以对map的key value进行取地址。1. key value 都是保存在bmap 中的key value 中，如果发生扩容，位置会变。使用unsafe 可以临时取，但是地址会失效。
- 如何比较两个map相等
    map 相等的情况如下：
    1. 都是nil
    2. 非空，长度相等，指向同一个hmap
    3. 长度相等遍历key 都相等
    4. == 只能用于 和 nil 比较
- 简单说一下map 读元素的过程
    1 拿到key 2. 计算key值得hash 3. 通过hash 值（hash 低位找到桶的索引； 4. 桶内有三个类型的元素，高八位，keys values 其中高8位记录了每个key值hash 值得高8位，通过比较快速找到索引
- sync.Map
    store load delete range 适应大量并发写
#### chan 
- CSP 模型： 通过通信实现内存共享（communicating Sequential Processes）
- chan 底层实现数据结构是什么？
    结构体：hchan
    重要字段：
	// 指向底层循环数组的指针
	// 只针对有缓冲的 channel
	buf      unsafe.Pointer
	// chan 是否被关闭的标志
	closed   uint32
	// chan 中元素类型
	elemtype *_type // element type
	// 已发送元素在循环数组中的索引
	sendx    uint   // send index
	// 已接收元素在循环数组中的索引
	recvx    uint   // receive index
	// 等待接收的 goroutine 队列
	recvq    waitq  // list of recv waiters
	// 等待发送的 goroutine 队列
	sendq    waitq  // list of send waiters
	// 保护 hchan 中所有字段
	lock mutex
- 发送数据过程是什么？
    考虑非阻塞模式/阻塞模式，channel 是否为nil; 缓冲/非缓冲 是否关闭 接收/发送goroutine 队列是否为空
- 接收数据过程是什么？
    考虑非阻塞模式/阻塞模式，channel 是否为nil; 缓冲/非缓冲 是否关闭 接收/发送goroutine 队列是否为空
- 关闭channel 会发生什么？关闭的过程是什么？
    关闭 nil 直接panic；关闭一个closed，panic；对于等待发送队列，会全部panic; 对全部待接收队列，都会获取对应类型的零值。
    其中select语法或者逗号ok语法中， 是否带获取值在底层源码中有相应的体现。
- 为什么并发安全？从源码角度讲下？
    因为在hchan结构体中，自带一个互斥锁字段，在操作时会加锁保证原子性。
- 讲一下chan 主要操作
    关闭： 关闭nil,关闭closed panic； 关闭 not nil not closed 正常关闭
    读取： 读取nil 阻塞，读取close 类型零值； 读取 not nil not closed: 缓冲型为空或者非缓冲型待接收队列为空，阻塞；其他情况正常读
    写入： 向nil 写入； 阻塞，向 closed 写入，panic ； 缓冲型未满或者等待接收协程队列非空，直接写入；其他情况阻塞
- 发送接收元素的本质是什么？
    非缓冲类型chan,就是将发送协程要发送的数据复制到接收协程需要的地方，对于缓冲类型的
   是将sender值拷贝到缓冲队列中，再从缓冲队列（数组）中复制到receiver中，本质上是值得拷贝。
- 怎么优雅的关闭channel 
    如果为单个sender 多个或一个receiver 直接sender端关闭
    多个sender 的情况：
        1. 多个sender一个receiver， 在receiver中发送关闭请求，然后sender端停止发送数据，让gc处理。不显式的关闭。
        2. 多个sender多个receiver， 通过中间人的方式关闭，只关闭一次
- chan 应用场景
    1. 停止信号，利用nil类型接收数据阻塞的特点，注意避免死锁
    2. 任务定时，结合select case 语法， 结合time 包进行定时任务执行，eg: time.After  or Tick 方法，这两个方法
    3. 生产者消费者模型，需要实现一个协程池************************
    4. 控制并发数，注意这里需要考虑并发同步的问题，使用sync.waitgroup实现，这里需要代码实现 ************************
#### interface
- 值接收者 指针接收者的区别，
所谓值接收者，指针接收者都是面向方法的，他们都是给指定的实现方法添加了一个接收者，这里类似python 中的self 和js 中的this
值类型和指针类型都可以调用对方实现的方法，区别在于传给函数的是地址还是副本
传递给函数的值的区别：
    传递给函数的是一个副本，在调用值接收者函数时，传给函数的是这个值的一个副本，调用指针接收者的函数时，传递的是一个地址（本质上都是值传递，只是值不同而已）
接口类型的变量中存在隐式转换的特点：
    接收者是值类型，会自动生成接收者是指针类型的方法， 相当于 func (b B)F(){}----> func (b *B)F(){}
    接收者是指针类型，不会自动生成接收者是值类型的方法。 func (b *B)F(){} XXXXXXXXXX> func (b B)F(){}
    这种情况一般在接口中存在多个函数定义时用到。
    有点绕.......................
- iface vs eface
区别：
    iface 描述的接口中包含方法   
    eface 只是空接口 ，只有定义空接口时才创建
    其中都包含了type 结构体类型，这里type 是golang中所有类型结构体的一个可以认为是一个基类，各种数据类型都是在_type基础上加字段进行修改的
- 接口的动态类型和动态值
    接口等于nil 的 条件： 接口的动态类型和动态值都为nil 时， 才为nil；
- 打印接口的动态类型和动态值
     使用unsafe包进行打印
- 类型转换和断言的区别
    类型转换前提是转化后两个类型要互相兼容
    类型断言是对接口进行操作
    type student struct {
        age int
    }
    eg: var i interface{} = new(student)
        s,ok := i.(student)
        if ok {
            ......
        }
    上述代码使用的是安全断言方法，这里的i是*student类型，所以这里会断言失败
    常见用法结合switch 语法进行多类型断言
    swithc v := v.(type){
        case nil:
            ***
        case string:
            ***
        case student:
            ***
        default:
            类型断言失败
    }
    请注意，这里的v 是接口类型的变量，右边的v 只是一个变量名
    注意，golang中函数传参， 类型断言都会生成一个新的类型副本，所以在打印地址时，要注意地址的变化

- 接口转化的原理
    接口转化的前提是类型兼容，简单理解就是方法集的包含关系
- 怎么使用interface实现多态
    多态特点：
        一种类型具有多种类型的能力
    示例：
        ```
            type Person interface {
                job()
                growUp()
            }


            func whatJob(p Person) {
                p.job()
            }

            func growUp(p Person) {
                p.growUp()
            }

            type Student struct {
                age int
            }

            // 这里student默认实现了指针接收者的接口
            func (p Student) job() {
                fmt.Println("I am a student.")
                return
            }

            func (p *Student) growUp() {
                p.age += 1
                return
            }

            type Programmer struct {
                age int
            }

            func (p Programmer) job() {
                fmt.Println("I am a programmer.")
                return
            }

            func (p Programmer) growUp() {
                // 程序员老得太快 ^_^
                p.age += 10
                return
            }

            func main() {
                qcrao := Student{age: 18}
                whatJob(&qcrao)

                growUp(&qcrao)
                fmt.Println(qcrao)

                stefno := Programmer{age: 100}
                whatJob(stefno)

                growUp(stefno)
                fmt.Println(stefno)
            }
        ```
#### 数组和切片
- 数组和切片的区别是什么？
    定义方式上： 数组是定长定类型的一种数据结构，长度同时为数组类型的一部分
                切片定义不需要指定长度，只需要指定类型，可以动态按照某种算法进行扩容，具有三个属性：指向底层数组的指针，切片长度（len），切片容量（cap）
    内存区别上：
                数组在内存中占用连续的空间，栈分配内存，访问速度更快，性能较高
                切片：？？？？？？？？
    适用场景上：
                数组适合存储固定已知数量的元素，切片适合处理未知大小或者经常变化的数据集
    函数传递上：   
                因为golang中函数传参都是值传递（指针本身也是一个值），数组作为参数可能会造成数据拷贝，造成性能问题；切片是引用传递，从切片的数据结构中可以理解，本质上也涉及到值复制，只不过这里复制的是地址和两个int类型的变量，性能消耗远小于数组的值复制，性能较高。同时函数内更改数据也会影响到原数据。    
    注意下方表示方法
    var S = make([]int,10,10)
    
- 切片怎么扩容？
    扩容时机和扩容策略
    append(s1,v)  追加单个元素
    append(s1,v...)  追加切片
    扩容时机： 当len == cap 时，再进行追加时，触发扩容
    扩容策略：cap 小于256， 2倍，大于256，new cap = oldcap + (oldcap + 3 * 256)/4
    特殊情况：
    	s := []int{1,2}
        s = append(s,4,5,6)
        fmt.Printf("len=%d, cap=%d",len(s),cap(s))   // len = 5 cap = 6  具体原因是源码中分配内存相关的函数造成的
- 向nil 或者 空的slice append 会发生什么？
    最终都是调用mallocgc分配内存赋值给nil slice empty slice，然后返回append之后的值。
- 切片作为参数
    同时注意值传递和指针传递
- slice map chan 特性对比
    对nil值操作
        slice nil 进行append 后，不报错，会先申请内存然后执行append操作，随后返回一个slice
        map nil 对nil 类型的map可进行赋值操作会发生panic
        对 nil chan 读写都会进入永久阻塞， 这里使用nil chan 对程序进行阻塞操作时，一定要确保至少有一个协程在持续运行才能避免死锁，注意go中的死锁检测
#### context 
- context 是什么，有什么作用？
    context 在golang 中是协程的上下文，一般用于在链式协程调用时传递信息。比如取消信号，超时时间，截至时间，k-v对等信息，主要还是用于并发控制，超时控制和传递信息。context 是并发安全的。
- 常见有几种类型
    withCancel
    withDeadline
    withTimeout
    withValue
- 应用场景
    http 服务中传递特定数据，管理超时，取消请求
    取消长时间运行的处理
    数据库超时检测
    避免协程泄漏
        func gen() <-chan int {
        ch := make(chan int)
        go func() {
            var n int
            for {
                ch <- n
                n++
                time.Sleep(time.Second)
            }
        }()
        return ch
    }

            func main() {

                for n := range gen() {
                    fmt.Println(n)
                    if n == 5 {
                        break
                    }
                }
            }
        这里main 函数结束后，内存中ch 没有释放,造成了协程泄漏
        协程泄漏指的是协程由于一些外部引用的存在（如通道、定时器、全局变量等）而不能被垃圾回收器回收，同时它们自身又因为一些同步操作（如通道操作、锁操作等）而无法继续执行或结束。在你的示例中，协程处于阻塞状态，尝试向通道 ch 发送数据，但无法继续因为缺少接收方。
        解决方法是,传递一个上下文,在main 函数停止时显式的终止gen中循环
- 管理超时一般代码实现
    在下游协程中，常见使用for + select 结合的形式进行操作
    for {
        select {
            case <- time.After(time.dur***):
                // 超时逻辑
            case ctx.Done()
                // 取消逻辑
        }
    }
    // 实际协程的操作逻辑
#### reflect 
- 什么是反射?
    Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。
- 什么时候用反射?
    不能明确传入函数的参数类型，需要在运行时处理任意对象。eg func t(i interface{}){}
    不能明确接口调用哪个函数，需要根据传入的参数在运行时决定。eg: 结构体 s 实现了两个方法 f1 f2,现在外部传了一个函数名,首先判断s 是否实现了这个函数,如果实现了调用该函数
- 为什么尽量不要用反射?
    1. 错误在运行后发现,而不是编译期间发现.(和动态语言类似,python)
    2. 反射特别慢,影响性能
- 反射为什么这么慢?????
- 反射如何实现?
TypeOf() 函数返回一个接口，这个接口定义了一系列方法，利用这些方法可以获取关于类型的所有信息； ValueOf() 函数返回一个结构体变量，包含类型信息以及实际值。
反射是一种检测存储在 interface 中的类型和值机制。这可以通过 TypeOf 函数和 ValueOf 函数得到。
将 ValueOf 的返回值通过 Interface() 函数反向转变成 interface 变量。
反射动态改变变量值前需要判断值是否可更改的
var x float64 = 3.4
p := reflect.ValueOf(x)
p.Canset()  // false

不能设置的原因: 这里p 只是x 的一个拷贝,所以不能对这个值进行操作

- 反射应用
    fmt 相关函数的实现
    序列化和反序列化
- 如何比较两个对象完全相同
    自带封装函数:
        reflect包下的:
        DeepEqual(x,y interface{}) boo;

#### unsafe
- go 指针 vs unsaft Pointer 区别
    1. go 指针不能运算,只能获取,区别于C C++
    2. 不能类型的指针不能相互转化
        a := int(1000)
        var f *float 
        f = &a  // 编译报错
    3. 不同类型的指针不能比较
    unsaft 包和指针的联系:
        1. unsafe.Pointer 可以与任何类型的指针互换,换句话说,任何类型指针都可以赋值给unsafe.Pointer类型变量
        2. uintptr 和 unsafe.Pointer 可以互换
        3. 上面两点可以推出: *T --> unsafe.Pointer--->uintptr,uintptr 可以参与数学运算
- unsafe 可以进行的操作
    可以修改结构体中私有成员的字段(此时注意结构体可能存在内存对齐,在使用uintptr进行数学计算时要注意)
    string byte 零拷贝转化(本质上是指针类型的转化,注意,这里指针转化有条件限制)
    
#### defer 注意点
1. 延迟调用,一般用于程序收尾工作.比如 资源释放,文件关闭,网络连接,解锁,等操作
2. 和return 一起使用,要特别注意return语句不是原子操作,根据函数是否存在返回值区分
    return 对返回变量赋值，如果是匿名返回值就先声明再赋值；
    执行 defer 函数；
    return 携带返回值返回。
3. 执行顺序:后进先出
4. defer 语句中函数参数被执行计算,在defer语句固定,不受运行时影响.
5. 常用处理异常,defer recover
func e1() { // 编译后传入nil,始终不变
	var err error
	defer fmt.Println(err)
	err = errors.New("e1 defer err")
}

func e2() {   // 闭包,真正执行时会捕获外部的变量
	var err error
	defer func() {
		fmt.Println(err)
	}()
	err = errors.New("e2 defer err")
}

func e3() {  // 编译时传入nil,始终不变
	var err error
	defer func(err error) {
		fmt.Println(err)
	}(err)
	err = errors.New("e3 defer err")
}

defer recover 示例代码

func safeDivision(num1, num2 int) (result int, err error) {
	defer func() {
		if r := recover(); r != nil {
			// 这里的 r 是 recover 捕获的 panic 值
			err = fmt.Errorf("panic caught: %v", r)
		}
	}()

	// 如果 num2 是0，则会触发 panic
	result = num1 / num2
	return result, nil
}

#### make vs new
- new 是给定类型T分配零值内并返回*T的指针,也就是指向类型T的零值的指针,使用new分配的内存被清零
- make 用于初始化内建的引用类型,map slice chan,返回的初始化后非零值的示例
区别:
    new 操作后没有分配内存,这样的特点是,对于常规类型(int float string),可以指针取值后直接使用,但是对于引用类型来说, 未分配内存,部分是不能直接赋值操作的,比如map,另外chan 对nil 的读取写入都是永久阻塞,slice对零值是可以append,所以尽量不要用new 来初始化引用类型
    
#### select 用法
   select 使得 goroutines 能够在多个通道操作上等待，直到其中一个操作可以执行时为止,一般与for 结合使用

#### 高效拼接字符串的方法
    首先解释下字符串的特性,不可变,当进行字符串拼接时,如果使用+,会涉及到多次的内存分配,并且每一次分配后会将拼接后的字符串赋值到新的内存地址中,然后依次执行,由于涉及到多次内存分配和复制,导致性能不高
    strings.Builder 内部维护了一个动态切片(数组),避免每次都复制整个字符串的过程,而且动态切片为按需递增,减少复制操作
    func JoinStrings(stringsToJoin ...string) string {
	var builder strings.Builder // 创建一个strings.Builder实例

	// 遍历所有传入的字符串参数
	for _, str := range stringsToJoin {
		builder.WriteString(str) // 使用WriteString方法将字符串添加到builder
	}

	return builder.String() // 将拼接后的字符串结果返回
}
#### GMP 模型

GMP 模型是 Go 语言的调度模型，是一种复合的调度模型，结合了 M:N 调度和 1:1 调度的特点。在 GMP 模型中，G 代表 Goroutine，M 代表 Machine（OS线程），而 P 代表 Processor（处理器上下文）。下面是这三个组件的作用及其交互方式：

1. **Goroutine (G)**：Goroutine 是 Go 语言中的轻量级线程，用于执行 Go 代码。Goroutines 是被多个线程并行执行的，但在任何时刻，一个 Goroutine 只能在一个线程上运行。

2. **Machine (M)**：M 是实际的操作系统线程，负责执行 Goroutines。M 需要持有一个 P 才能执行 G，否则它将处于等待状态，或者去获取一个空闲的 P。

3. **Processor (P)**：P 是代表 CPU 的逻辑执行上下文，包含运行 Goroutine 所需的资源，如调度信息和内存分配状态。P 的数量通常受 GOMAXPROCS 环境变量控制，这个变量定义了可以同时执行 Go 代码的系统线程的最大数目。

#### 实现原理
在 GMP 模型中：
- 每个 P 维护一个本地的 Goroutine 队列，它会调度队列中的 Goroutine 到 M 上执行。
- 当 M 处理完当前的 G 后，它会从与之关联的 P 的本地队列中获取下一个 G 来执行。
- 如果 P 的本地队列为空，M 可以尝试从其他 P 的本地队列中窃取 G，或者从全局队列中获取 G。
- 如果 M 因为没有可用的 G 而闲置，它会进入休眠状态，直到有新的 G 被调度。

### 用户协程和系统级线程调度方式区别

用户协程（如 Goroutine）和系统级线程（如操作系统线程）在调度方式上有显著的区别：

1. **调度器的控制层级**：
   - **用户协程**：由语言运行时控制的调度器进行管理，例如 Go 的调度器。这种调度器运行在用户空间，不需要内核介入，因此调度开销通常较小。
   - **系统级线程**：由操作系统的调度器管理，这涉及到内核空间的操作，每次上下文切换需要更多的处理时间和资源。

2. **上下文切换成本**：
   - 用户协程的上下文切换通常只涉及少量寄存器的改变，因此成本较低。
   - 系统级线程的上下文切换涉及整个线程状态的保存与恢复，包括内存映射、寄存器状态等，开销更大。

3. **可扩展性**：
   - 用户协程因为其轻量级和低成本的上下文切换，可以支持数十万甚至数百万的并发实体。
   - 系统级线程由于资源和调度成本限制，难以达到如此高的并发数。

4. **灵活性和优化**：
   - 用户协程调度器可以根据程序的具体需求和行为进行优化，如 Go 调度器的工作窃取算法。
   - 系统级线程的调度策略更加通用，由操作系统统一管理，不容易针对特定应用进行优化。

总结来说，GMP 模型通过有效地结合用户协程和系统线程的优点，实现了高效和灵活的并发执行，同时保持调度开销在较

低水平。

#### GC 实现原理
- 常见GC算法
    引用计数法--python
        优点：简单直接，回收速度快
        缺点：需要额外的空间存放计数，无法处理循环引用的情况；
    标记清除法
        标记出所有不需要回收的对象，标记完成后统一回收未被标记的对象
        优点：
            简单直接，速度快，使用可回收对象不多的场景
        缺点：
            内存碎片多，导致大对象创建时， 可能显示内存不够
    复制法：
        复制法将内存分为大小相同的两块，每次使用其中的一块，当这一块的内存使用完后，将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉
        优点：
            解决了内存碎片的问题，每次清除针对的都是整块内存，但是因为移动对象需要耗费时间，效率低于标记清除法
        缺点：
            有部分内存总是利用不到，资源浪费，移动存活对象比较耗时，并且如果存活对象较多的时候，需要担保机制确保复制区有足够的空间可完成复制；
    标记整理
        标记过程同标记清除法，区别是：结束后将存活对象压缩至一端，然后清除边界外的内容
        优点：
            解决了内存碎片的问题，每次清除针对的都是整块内存，但是因为移动对象需要耗费时间，效率低于标记清除法
        缺点：
            有部分内存总是利用不到，资源浪费，移动存活对象比较耗时，并且如果存活对象较多的时候，需要担保机制确保复制区有足够的空间可完成复制；
    分代式
        将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。
    Golang的垃圾回收（GC）算法使用的是无无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。原因在于：

        对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。但 Go 运行时的分配算法基于tcmalloc，基本上没有碎片问题。 并且顺序内存分配器在多线程的场景下并不适用。Go 使用的是基于tcmalloc的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。

        分代GC依赖分代假设，即GC将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。

        Go 的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代GC回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当goroutine死亡后栈也会被直接回收，不需要GC的参与，进而分代假设并没有带来直接优势。

        Go 的垃圾回收器与用户代码并发执行，使得 STW 的时间与对象的代际、对象的 size 没有关系。Go 团队更关注于如何更好地让 GC 与用户代码并发执行（使用适当的 CPU 来执行垃圾回收），而非减少停顿时间这一单一目标上。
    三色标记法原理
        三色标记法将对象分为三类，并用不同的颜色相称：

        白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。

        灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。

        黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。
    标记过程如下：

        （1）起初所有的对象都是白色的；

        （2）从根对象出发扫描所有可达对象，标记为灰色，放入待处理队列；

        （3）从待处理队列中取出灰色对象，将其引用的对象标记为灰色并放入待处理队列中，自身标记为黑色；

        （4）重复步骤（3），直到待处理队列为空，此时白色对象即为不可达的“垃圾”，回收白色对象；
    根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：

        全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
        执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
        寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。
    屏障机制
        STW
        STW 可以是Stop The World的缩写，也可以是Start The World的缩写。通常意义上指的是从Stop The World到Start The World这一段时间间隔。垃圾回收过程中为了保证准确性、防止无止境的内存增长等问题而不可避免的需要    停止赋值器  进一步操作对象图以完成垃圾回收。STW时间越长，对用户代码造成的影响越大
    垃圾回收的原则是不应出现对象的丢失，也不应错误的回收还不需要回收的对象。如果同时满足下面两个条件会破坏回收器的正确性：

        条件 1: 赋值器修改对象图，导致某一黑色对象引用白色对象；（通俗的说就是A突然持有了B的指针，而B在并发标记的过程中已经被判定为白色对象要被清理掉的）

        条件 2: 从灰色对象出发，到达白色对象且未经访问过的路径被赋值器破坏；（通俗的说就是A持有B的指针，这个持有关系被释放）

        只要能够避免其中任何一个条件，则不会出现对象丢失的情况，因为：

        如果条件 1被避免，则所有白色对象均被灰色对象引用，没有白色对象会被遗漏；
        如果条件 2 被避免，即便白色对象的指针被写入到黑色对象中，但从灰色对象出发，总存在一条没有访问过的路径，从而找到到达白色对象的路径，白色对象最终不会被遗漏。

        可能的解决方法： 整个过程STW，浪费资源，且对用户程序影响较大，由此引入了屏障机制；

        把回收器视为对象，把赋值器视为影响回收器这一对象的实际行为（即影响 GC 周期的长短），从而引入赋值器的颜色：

        黑色赋值器：已经由回收器扫描过，不会再次对其进行扫描。
        灰色赋值器：尚未被回收器扫描过或尽管已经扫描过，但仍需要重新扫描。


        插入屏障（Dijkstra）- 灰色赋值器---写入前，对指针所要指向的对象进行着色，避免黑色对象直接指向白色对象
        避免条件1（ 赋值器修改对象图，导致某一黑色对象引用白色对象；）因为在对象A 引用对象B 的时候，B 对象被标记为灰色
        Dijkstra 插入屏障的好处在于可以立刻开始并发标记。但存在两个缺点：

        由于 Dijkstra 插入屏障的“保守”，在一次回收过程中可能会残留一部分对象没有回收成功，只有在下一个回收过程中才会被回收；

        在标记阶段中，每次进行指针赋值操作时，都需要引入写屏障，这无疑会增加大量性能开销；为了避免造成性能问题，Go团队在最终实现时，没有为所有栈上的指针写操作，启用写屏障，而是当发生栈上的写操作时，将栈标记为灰色，但此举产生了灰色赋值器，将会需要标记终止阶段 STW 时对这些栈进行重新扫描。

        简单来说，堆区内存赋值时触发插入屏障，禁止黑色对象直接指向白色对象。栈区不触发，但是回收白色对象时，会启用stw机制，重新扫描直到栈区没有灰色对象，然后清理白色对象
        
        删除屏障 （Yuasa）- 黑色赋值器
        避免条件2（从灰色对象出发，到达白色对象的、未经访问过的路径被赋值器破坏），因为被删除对象，如果自身是灰色或者白色，则被标记为灰色

        简单来说，就是删除对象时，如果为白色，则先标记为灰色

        特点：标记结束不需要STW，但是回收精度低，GC 开始时STW 扫描堆栈记录初始快照，保护开始时刻的所有存活对象；且容易产生“冗余”扫描；

        混合屏障
            大大缩短了 STW 时间

            GC 开始将栈上的对象全部扫描并标记为黑色；
            GC 期间，任何在栈上创建的新对象，均为黑色；
            被删除的堆对象标记为灰色；
            被添加的堆对象标记为灰色；
    标记清理
        Marking setup
        为了打开写屏障，必须停止每个goroutine，让垃圾收集器观察并等待每个goroutine进行函数调用， 等待函数调用是为了保证goroutine停止时处于安全点。

    此类goroutine 能被异步抢占，使得进入STW的时间不会超过抢占信号触发的周期，程序也不会因为仅仅等待一个goroutine的停止而停顿在进入STW之前的操作上。

    一旦写屏障打开，垃圾收集器就开始标记阶段，垃圾收集器所做的第一件事是占用25%CPU。

    标记阶段需要标记在堆内存中仍然在使用中的值。首先检查所有现goroutine的堆栈，以找到堆内存的根指针。然后收集器必须从那些根指针遍历堆内存图，标记可以回收的内存。

    当存在新的内存分配时，会暂停分配内存过快的那些 goroutine，并将其转去执行一些辅助标记（Mark Assist）的工作，从而达到放缓继续分配、辅助 GC 的标记工作的目的。

    关闭写屏障，执行各种清理任务（STW - optional ）

    主动触发（runtime.GC()） 被动触发 （GC百分比、定时）

    GC 百分比
    运行时中有GC 百分比的配置选项，默认情况下为100。此值表示在下一次垃圾收集必须启动之前可以分配多少新内存的比率。将GC百分比设置为100意味着：基于在垃圾收集完成后标记为活动的堆内存量，下次垃圾收集前，堆内存使用可以增加100%。


    关注指标与调优示例
    关注指标
    Go 的 GC 被设计为成比例触发、大部分工作与赋值器并发、不分代、无内存移动且会主动向操作系统归还申请的内存。因此最主要关注的、能够影响赋值器的性能指标有：

    CPU 利用率：回收算法会在多大程度上拖慢程序？有时候，这个是通过回收占用的 CPU 时间与其它 CPU 时间的百分比来描述的。
    GC 停顿时间：回收器会造成多长时间的停顿？目前的 GC 中需要考虑 STW 和 Mark Assist 两个部分可能造成的停顿。
    GC 停顿频率：回收器造成的停顿频率是怎样的？目前的 GC 中需要考虑 STW 和 Mark Assist 两个部分可能造成的停顿。
    GC 可扩展性：当堆内存变大时，垃圾回收器的性能如何？但大部分的程序可能并不一定关心这个问题。

#### gin 常见知识点

#### gorm 

#### linux

#### https ssh

#### 限流算法
- 令牌桶
- nginx 配置
- web 中间件配置

#### redis

#### nginx
#### jwt
#### restful
#### 并发安全的map sync.Map store load delete range
