#### Docker目前主要有以下三个用途：

- 提供一次性的环境：本地测试别人的软件、持续集成的时候提供单元测试和构建的环境。
- 提供弹性的云服务：因为Docker容器可以随时启动或关闭，所以非常适合动态规划和缩容。
- 组建微服务构架：通过多个容器，服务的部署能更加灵活，帮助实现微服务构架。

#### 常见名词解释
- docker  是一个运行程序，功能是可以将应用程序以及依赖打包到image文件中
- image   一个二进制文件， 用于生成容器，一般使用
- 容器实例： docker 运行image文件，生成容器
- dockerfile  创建docker image file
- 端口映射 参数-p  eg:docker run -p 5000:3000 my-app
- 数据管理，也就是文件挂载：两种方式
    - bind mount: 将本地的一个文件夹与docker容器中的另外一个文件夹同步，参数  -v <local_folder_path>:<container_folder_path> 参数
        命令： eg:docker run -p 3000:3000 -v /Users/enoch/code_hub/1.turing_planet/docker-tutorial/2-common-commands/volume/volume_data:/app/volume_data volume-app-frontend
    - docker vloume 方式，区别于 bind mount 需要提前建立文件夹,vloume 
- docker conpose 
- 作用： 配置多个docker容器启动配置


##### rabbitMQ 常见问题
- 四大核心概念
    - 生产者
    - 交换机
    - 队列
    - 消费者
    - broker 接收和分发消息的应用
    - Virtual host   用于权限隔离，虚拟分组，可以划分多个vhost，用户在自己的vhost中创建exchange / queue
    - connection  生产者/消费者 与 broker 之间的TCP 连接， 这里协议是
    - channel 基于connection 内部建立的逻辑连接，轻量级的connection,复用tcp连接，减少损耗
    - exchange 交换机，消息到达broker 的第一站，根据分发规则，查询路由表的路由键，将消息发送到不同的队列中，其中交换机分为四个类型：driect exchange（exchange 根据消息的路由键，找到所有的与之绑定的队列比较，如果相等，就发送，没有匹配的就丢弃？？？？？？，待验证）topic exchange（区别于direct交换机中的路由键，这里可以使用指定的匹配规则键XXXX.XXXX.XXXX.），fanout exchange(忽略路由键，将消息转发到binding的所有队列)；header exchange （根据消息headers进行路由匹配）
    - queue 消息保存结构，本质上是个缓存区，消息经过路由后，最终到queue中等待消费者接收
    - binding exchange 和 queue之间的虚拟连接，binding 中可以包含routing，也就是binding规定了交换机将以何种路由方式将消息发送到哪个队列，用于exchange分发数据
- 四种工作模式
    - 简单模式 simple  一个生产者一个消费者
    - 路由模式
    - 主题模式
    - RPC模式
- 消息分发
    - 默认为轮询分发，缺点：不能应对消费节点性能来区分
    - 不公平分发： 设置参数channel.basicQos(1),含义是任务没有处理完成并完成应答，先暂停分配
    - 限流： 通过使用 basic.qos 方法设置“预取计数”值来完成的。该值定义通道上允许的未确认消息的最大数量。100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为 1 是最保守的。
- 消息确认
    - 发布确认
        - 单个确认发布
        - 批量确认发布
        - 异步确认发布
    - 消息应答
        - 自动应答  这种模式需要在高吞吐量和数据传输安全性方面做权衡,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用
        - 手动应答  
            - ack
            - Nack
            - reject 直接拒绝
    - 重新入队
        - requeue 参数，适用场景： 
- 持久化
    - 队列持久化 默认为非持久化，
    - 消息持久化    不能完全保证不丢失消息， 如果需要更强有力的持久化策略，可以增加发布确认。
- 队列
    - 死信队列
         - 造成的原因
            - ttl 过期
            - 队列超过最大长度，无法添加数据
            - 消息被拒
    - 设置死信队列
        - 死信队列和普通队列一样，也需要声明队列和对应的交换机，路由键等，
    - 延迟队列
        - 延时队列内部是有序的。特点是希望在指定时间到了以后再取出处理，换句话讲，用于存放需要在指定时间被处理的元素的队列。
    - 惰性队列
        - 惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。
- TTL 
    - 是rabbitmq 中队列或者消息的一个属性，表示最大存活时间，单位毫秒。如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为”死信”。如果同时配置了队列的 TTL 和消息的TTL，那么较小的那个值将会被使用。
    - 队列ttl 是面向消息的吗？
- 幂等性
    - 防止重复消费，触发场景： 在消息消费确认模式下，消息消费成功后，发送ack确认时或者消息本身存在问题拒绝消费发送nack时，网络波动，造成发送确认消息失败，mq 没有收到确认消息会将消息重新发送到其他消费者，造成重复消费。为了解决这个问题，给每个消息指定唯一性ID，结合缓存，在消费前判断下。
Q&A:






##### docker rabbitmq 集群搭建

